{% load static %}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../static/css/style.css"">
    <title>Suguru Solver</title>
</head>
<body class="bg-slate-700">

    <div class="mx-auto bg-pink-400 text-cyan-200 w-fit p-6 rounded-tl-md rounded-br-md my-6">
        Hello World
    </div>

    <div id="grid"></div>

    <button id="mergeRegionButton" class="block mx-auto bg-pink-600 text-white w-fit p-6 rounded-tl-md rounded-br-md my-6">
        <p>Merge Region</p>
    </button>

    <script>
        const m = 4, n = 4;
        const BASE_CELL_MARGIN_LENGTH = 8, BASE_CELL_WH_SIZE = 192; // in pixel
        const action = {id: -1, regionCounter: 0, isCursorDragging: false};
        const cellRegion = Array.from({length: m*n + 1}, (_, i) => 0);

        const cellOrder = (i, j) => (i-1)*m + j;
        const toCell = (order) => [Math.ceil(order/n), ((order-1) % n) + 1];
        const insideGrid = (i, j) => (1 <= i && i <= m && 1 <= j && j <= n);
        const isAdjacent = ([i, j], [x, y]) => (Math.abs(i-x) <= 1 && Math.abs(j-y) <= 1 && Math.abs(i-x) + Math.abs(j-y) == 1);

        const createElementWithStyles = (elementType, [...styles]) => {
            const element = document.createElement(elementType);
            styles.forEach((style) => {
                element.classList.add(style);
            });
            return element;
        }

        // border-b-[4px] border-t-[4px] border-r-[4px] border-l-[4px] 
        const createCell = (i, j) => {
            const cell = createElementWithStyles('div', ['bg-white', 'border-gray-600', 'cell', 'flex', 'justify-center', 'items-center']);
            cell.id = `c${cellOrder(i, j)}`;
            cell.style.width = `${BASE_CELL_WH_SIZE}px`;
            cell.style.height = `${BASE_CELL_WH_SIZE}px`;

            [[1, 0, 'b'], [-1, 0, 't'], [0, 1, 'r'], [0, -1, 'l']].forEach(([dx, dy, dir]) => {
                if (insideGrid(i + dx, j + dy))
                    cell.classList.add(`border-${dir}-[4px]`);
            });

            const child = createElementWithStyles('p', ['text-5xl', 'flex', 'justify-center', 'items-center']);
            child.contentEditable = true;
            child.style.width = `${Math.floor(BASE_CELL_WH_SIZE/2)}px`;
            child.style.height = `${Math.floor(BASE_CELL_WH_SIZE/2)}px`;
            cell.appendChild(child);

            return cell;
        }

        // border-b-gray-300 border-t-gray-300 border-r-gray-300 border-l-gray-300
        const purgeCellRegion = (i, j) => {
            [[1, 0, 'b', 't'], [-1, 0, 't', 'b'], [0, 1, 'r', 'l'], [0, -1, 'l', 'r']].forEach(([dx, dy, dirA, dirB]) => {
                if (insideGrid(i + dx, j + dy))
                    if (cellRegion[cellOrder(i, j)] == cellRegion[cellOrder(i + dx, j + dy)]) {
                        document.querySelector(`#c${cellOrder(i, j)}`).classList.add(`border-${dirA}-gray-300`);
                        document.querySelector(`#c${cellOrder(i + dx, j + dy)}`).classList.add(`border-${dirB}-gray-300`);
                    } else {
                        document.querySelector(`#c${cellOrder(i, j)}`).classList.remove(`border-${dirA}-gray-300`);
                        document.querySelector(`#c${cellOrder(i + dx, j + dy)}`).classList.remove(`border-${dirB}-gray-300`);
                    }
            });
        }

        const applyRegionChanges = ([i, j], {regionCounter}) => {
            cellRegion[cellOrder(i, j)] = regionCounter;
            purgeCellRegion(i, j);
        }

        const initializeEmptyGrid = () => {
            const grid = document.querySelector('#grid');
            grid.innerHTML = '';
            grid.className = 'bg-gray-900 flex flex-wrap mx-auto h-fit';
            grid.style.width = `${BASE_CELL_WH_SIZE*n}px`

            for (let i = 1; i <= m; i++)
                for (let j = 1; j <= n; j++)
                    grid.appendChild(createCell(i, j));
            
            for (let i = 1; i <= m; i++)
                for (let j = 1; j <= n; j++)
                    purgeCellRegion(i, j);            
        }
    
        // Events
        const initializeEvents = () => {
            document.querySelector('#mergeRegionButton').addEventListener("click", (event) => {
                if (action.id !== 1) {
                    action.id = 1, action.regionCounter++;
                    event.target.innerHTML = 'Done Merging Region';
                }
                else {
                    action.id = -1;
                    event.target.innerHTML = 'Merge New Region';
                }
                document.querySelectorAll(".cell").forEach((element) => {
                    element.querySelector('p').contentEditable = (action.id !== 1);
                    element.style.userSelect = (action.id !== 1 ? 'auto' : 'none');
                });
            });

            document.querySelectorAll(".cell").forEach((element) => {
                element.addEventListener("mousedown", function(event) {
                    action.isCursorDragging = true;
                });

                element.addEventListener("mouseup", function(event) {
                    action.isCursorDragging = false;
                });

                element.addEventListener("mousemove", function(event) {
                    if (!action.isCursorDragging || action.id != 1)
                        return;

                    const [i, j] = toCell(parseInt(event.target.id.substring(1)));
                    applyRegionChanges([i, j], action);
                });
            });

            document.body.addEventListener("mousedown", function(event) {
                action.isCursorDragging = true;
            });

            document.body.addEventListener("mouseup", function(event) {
                action.isCursorDragging = false;
            });
        }


        initializeEmptyGrid();
        initializeEvents();
    </script>
</body>
</html>